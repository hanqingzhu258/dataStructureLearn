//
// Description: 生成树和最小生成树
//              生成树：一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有构成一棵树的（n-1）条边
//              最小生成树：对于一个带权（假定权均为大于零的实数）连通无向图G中的不同生成树，其每棵树的所有边上
//                        权值之和也可能不同；图的所有生成树中具有边上的权值之和最小的树成称为图的最小生成树。
// Created by hanqing zhu on 2018/11/26.
//

/*------------------------------------------------------
 *
 * 构造最小生成树的准则：
 *  （1）必须只使用该图中的边来构造最小生成树；
 *  （2）必须使用且仅使用（n-1）条边来连接图中的n个顶点；
 *  （3）不能使用产生回路的边
 * 
 * author： hanqing zhu 2018/11/26 16:38
 * -----------------------------------------------------*/

#include "unit2.h"

#ifndef CHAPTER8_UNIT4_H
#define CHAPTER8_UNIT4_H

/*------------------------------------------------------
 *
 * INF表示OO
 *
 * author： hanqing zhu 2018/11/27 9:42
 * -----------------------------------------------------*/
#define INF 32767

/*------------------------------------------------------
 *
 * 普里姆算法
 *
 * author： hanqing zhu 2018/11/27 9:43
 * -----------------------------------------------------*/
void prim(MGraph g,int v);


/*------------------------------------------------------
 *
 * 克鲁斯卡尔算法
 *
 * author： hanqing zhu 2018/11/27 10:14
 * -----------------------------------------------------*/
typedef struct {
    //边的起始顶点
    int u;
    //边的终止顶点
    int v;
    //边的权值
    int w;
}Edge;

void Kruskal(MGraph g);

/*------------------------------------------------------
 *
 * 对边按权值进行插入排序
 *
 * author： hanqing zhu 2018/11/27 10:31
 * -----------------------------------------------------*/
void insertSort(Edge E[MaxSize],int e);

#endif //CHAPTER8_UNIT4_H
